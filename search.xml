<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[本地配置多个 github 账号]]></title>
    <url>%2Fgit-config%2F</url>
    <content type="text"><![CDATA[今天突然想折腾一下 git ，想在同一台电脑配置多个 github 账号，其他平台同理，他们都是通过 SSH 密钥配对的方式进行验证的，所以只需要在本地生成多个 SHH 密钥即可 准备 两个 github 账号 本地 Git 安装 如果还没有使用过 Git 移步廖雪峰老师的 Git 教程 学习基本配置和使用 再推荐 git pro 手册, 很全面 想到配置多个 github 的情况应该都是使用过 git ，但是由于工作或其他原因需要使用其他账号，所有本文是在已经配置好一个 github 账号的情况下配置的，所以需要对 Git 有一定的了解，如果第一次使用请看 3↑ Let’s Go 说明： 本文以 Mac OS X系统配置,下面是Windows 和 Mac .shh目录说明若是不能看见.shh 文件，请确定系统开启隐藏文件可见，mac 快捷键:⌘ + ⇧ + .，Windows：点击窗口上查看选项，然后开启隐藏文件可见即可 12345 # 打开终端 # 进入mac .ssh 目录➜ cd ~/.ssh # Windows .shh 目录➜ cd C:\Users\Administrator\.ssh 第一步创建第二个 shh 密钥123➜ ssh-keygen -t rsa -f id_rsa_second -C &quot;your second email&quot; # &apos;id_rsa_second&apos; 这是第二个 ssh 密钥的名字，可以任意修改，不能使用中文# &apos;your second email&apos; 这是创建第二个 github 账号的邮箱 查看是否创建成功: 输入ls查看**123➜ .ssh lsid_rsa id_rsa_second known_hostsid_rsa.pub id_rsa_second.pub next 将密钥添加到 github 账户(略略略~)next 为 git 添加配置文件config 命令如下 1234567891011121314151617# 创建 config 配置文件➜ touch config# 编辑 config 配置文件➜ nano config // 添加如下配置# default github configHost git@github.com # 默认配置 HostName github.com User git IdentityFile ~/.ssh/id_rsa #默认 ssh#Second github configHost second # 第二个账户 HostName github.com User git IdentityFile ~/.ssh/id_rsa_second # 注意文件名 下面添加新的 ssh 123456789# 清除本地缓存➜ ssh-add -D# 添加 ssh➜ ssh-add id_rsa_second# 确认是否添加成功➜ shh-add -l#验证两个账号是否可用➜ .ssh ssh -T git@github.comHi **Your Name**! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 说明：git 还有另外一个配置文件.gitconfig,当你第一次配置全局用户信息，就会生成。那这俩个文件会冲突吗？答案是：不会。使用过程中，git 会先查找.gitconfig（.gitconfig 是全局配置）,然后 git 还会继续检查git 目录下是否有config，如果有那么就会以此配置为准 以上都没问题就配置成功了，下面就可以开始使用了 第一个是默认账户，和以前使用完全一样，不用作任何修改 第二账户如何使用呢？ 克隆：git clone second:xxxx/xxxxx.git 链接远程仓库:git remote add origin second:xxxx/xxxx.git 区别在哪儿？就是我们配置的 HOST ，好了愉快的使用吧~]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识伪类、伪元素]]></title>
    <url>%2F2017-08-28-1%2F</url>
    <content type="text"><![CDATA[常用伪类 连接伪类 ：link:向未访问的链接添加特殊的样式 :visited:设置访问过的页面链接的样式 动态伪类 :focus:指示当前拥有输入焦点的元素 :hover:当有鼠标悬停在其上的链接样式 :active:设置当你点击链接时的样式。 注意：伪类的顺序很重要，一般顺序：link-visited-focus-hover-active :target伪类 不是HTML的a标签里面那个target属性。target伪类是css3的新属性。官方定义是：URL 带有后面跟有锚名称#，指向文档内某个具体的元素。这个被链接的元素就是目标元素(target element)。:target 选择器可用于选取当前活动的目标元素。 有木有feel到target跟其他伪类的与众不同?!利用target的特性，可以实现纯css的tab效果切换。先根据target的特性锚链接到对应的div,再根据z-index的属性，改变div的层级关系，从而实现tab的切换效果！** 实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;style&gt;.tabmenu &#123; position:absolute; top:100%; margin:0;&#125;.tabmenu li&#123; display:inline-block;&#125;.tabmenu li a &#123; display:block; padding:5px 10px; margin:0 10px 0 0; border:1px solid #91a7b4; border-radius:0 0 5px 5px; background:#e3f1f8; color:#333; text-decoration:none;&#125;.tablist &#123; position:relative; margin:50px auto; min-height:200px;&#125;.tab_content &#123; position: absolute; width:600px; height:170px; padding:15px; border:1px solid #91a7b4; border-radius:3px; box-shadow:0 2px 3px rgba(0,0,0,0.1); font-size:1.2em; line-height:1.5em; color:#666; background:#fff; &#125; #tab1:target, #tab2:target, #tab3:target &#123; z-index: 1;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="tablist"&gt; &lt;ul class="tabmenu"&gt; &lt;li&gt;&lt;a href="#tab1"&gt;tab1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#tab2"&gt;tab2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#tab3"&gt;tab3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id="tab1" class="tab_content"&gt;tab1&lt;/div&gt; &lt;div id="tab2" class="tab_content"&gt;tab2tab2&lt;/div&gt; &lt;div id="tab3" class="tab_content"&gt;tab3tab3tab3&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其他伪类：:first-child:可以选择元素的第一个子元素:not(selector)：否定伪类选择器用来在匹配元素时排除某些元素。123div:not(#container) &#123; color: blue; &#125; 在上面的例子中，设定除了id为container的div元素字体颜色为blue。 :nth-child(n):123li:nth-child(3) &#123; color: red; &#125; 这个伪类用于设定一个序列元素（比如li、tr）中的第n个元素（从1开始算起）的样式。在上面例子中，设定第三个列表元素li的字体颜色为红色。 看一个更灵活的用法，在下面例子中设定第偶数个元素的样式，可以用它来实现隔行换色：123tr:nth-child(2n) &#123; background-color: gray; &#125; 推荐：Mastering the :nth-child :nth-last-child(n)123li:nth-last-child(2) &#123; color: red; &#125; 与:nth-child(n)功能类似，不同的是它从一个序列的最后一个元素开始算起。上面例子中设定倒数第二个列表元素的字体颜色。 :nth-last-child(n)123li:nth-last-child(2) &#123; color: red; &#125; 与:nth-child(n)功能类似，不同的是它从一个序列的最后一个元素开始算起。上面例子中设定倒数第二个列表元素的字体颜色。 :nth-of-type(n)123ul:nth-of-type(3) &#123; border: 1px solid black; &#125; 与:nth-child(n)功能类似，不同的是它匹配的不是某个序列元素，而是元素类型。例如上面的代码设置页面中出现的第三个无序列表ul的边框。 :nth-last-of-type(n)1ul:nth-last-of-type(3) &#123; border: 1px solid black; &#125; 与:nth-of-type(n)功能类似，不同的是它从元素最后一次出现开始算起。上面例子中设定倒数第三个无序列表的边框 :lang：为不同的语言定义特殊的规则 伪类比属性选择器稍微健壮一些，在需要语言特定的样式时，可以选择伪类 注意：在IE8的之前版本必须声明&lt;!DOCTYPE&gt; , 才能生效。 伪元素１. :before和:after (向文档中插入生成内容) :before:用来给指定的元素的内容前面添加新的内容。 :after:用来给指定的元素的内容后边添加新的内容。 添加的新内容区域默认的display属性为:inline可以像修改其他元素一样修改它的样式。 content属性 属性content是否为必选？移除content试试。或者内容设置为空呢？ content属性的值还可以是其他形式，比如插入一张图片：注意不能使用引号。如果你将URL用引号括起来，那么它会变成一个字符串和插入文本“url(image.jpg)”作为其内容，插入的而不是图像本身。 content:url(img/icon.png);插入字符串插入属性值【attr】（如果一个属性不存在，会在相应位置插入一个空串）；生成引号、插入引号等。 如果要使用弯引号，quote规则要写作quote{quotes:&#39;\201C&#39; &#39;\201D&#39;}这里使用的十六进制的Unicode值。 伪元素通常配合伪类使用 eg：:before经常与:hover配合使用 :after特征与:before一致 伪元素:first-line：用于向文本的首行设置特殊样式。浏览器会根据 “first-line”伪元素中的样式对p元素的第一行文本进行格式化。 伪元素:first-letter ：用于向文本的首字母设置特殊样式 注意：first-letter伪元素只能用于块级元素。 伪类和伪元素的区别 w3c 对两者的定义： CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。 两者都与选择器相关，可以添加一些“特殊”的效果。 区别：用伪类 :first-child 和伪元素 :first-letter 来进行比较。12345p&gt;i:first-child &#123;color: red&#125;&lt;p&gt; &lt;i&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt; 伪类 :first-child 添加样式到第一个子元素如果我们不使用伪类，而希望达到上述效果，可以这样做：12345.first-child &#123;color: red&#125;&lt;p&gt; &lt;i class=&quot;first-child&quot;&gt;first&lt;/i&gt; &lt;i&gt;second&lt;/i&gt;&lt;/p&gt; 我们给第一个子元素添加一个类，然后定义这个类的样式。 伪元素：12p:first-letter &#123;color: red&#125;&lt;p&gt;I am stephen lee.&lt;/p&gt; 伪元素 :first-letter 添加样式到第一个字母那么如果我们不使用伪元素，要达到上述效果，我们可以这样做：12.first-letter &#123;color: red&#125;&lt;p&gt;&lt;span&gt;I&lt;/span&gt; am stephen lee.&lt;/p&gt; 即给第一个字母添加一个 span，然后给 span 增加样式。 两者的区别已经出来了。那就是：伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo+Github免费搭建个人博客]]></title>
    <url>%2F2017-08-28%2F</url>
    <content type="text"><![CDATA[记录本次重新搭建个人博客 工具 Hexo GitHub 环境搭建 Nodejs安装 建议使用淘宝镜像 Git安装 开始搭建 Hexo文档有详细介绍，请仔细阅读安装hexo 打开终端输入npm install -g hexo-cli 检测是否成功安装输入hexo得到如下结果 初始化博客 依次执行如下命令 1234hexo init Blog // Blog可以换成任意名字，只是一个文件夹名字 cd Blog // 进入到Blog文件夹npm install hexo generate 初始化结束文件目录如下：目录结构说明 本地预览输入hexo server 然后打开浏览器输入http://localhost:4000即可预览博客 先阅读文档熟悉下hexo配置文件然后自己修改玩一玩，修改之前请备份 安装主题 选择一款自己喜欢的主题，这里有很多选择 下载主题 输入命令cd themes进入themes/文件夹下面 克隆主题到此目录下，我选择的next主题，文档比较详细之后的配置可以按照文档一步一步配置即可 克隆完成之后修改hexo配置文件: 12搜索并修改theme, 然后输入hexo s预览theme: hexo-theme-next 注意：安装主题之后我们要修改两个配置文件，一个是hexo配置文件【Blog目录下的config.yml文件】以下称hexo配置文件_，一个是主题配置文件【Blog/themes/相应主题/ 目录下的config.yml文件】以下称主题配置文件_ 部署到github 打开hexo配置文件找到deploy,我的配置如下 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/FerdYing/FerdYing.github.io.git // 换成你的仓库地址 branch: master 保存文件，继续在终端依次输入如下命令 12npm install hexo-deployer-git --savehexo deploy // 部署到github 第一次要求输入github用户名和密码，输入密码的时候是不显示的，输完回车继续 部署完毕~访问尝试一波吧~~ 博客个性化设置(可以跟着next文档把各种配置都玩一下) 我的hexo配置如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/ # Sitetitle: FerdYing&apos;s Blogsubtitle: Stay hungry Stay foolishdescription: 学习总结 思考感悟 知识管理author: FerdYingemail: ferdying@163.comlanguage: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://github.com/FerdYing/FerdYing.github.io.gitroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace:# Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml# 搜索search: path: search.xml field: post format: html limit: 10000# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hexo-theme-next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/FerdYing/FerdYing.github.io.git branch: master 主题配置 评论使用Disqus，按照文档设置之前需要去Disqus注册/登录获取shortname，然后再配置（需翻墙） 配置分类和标签页面输入hexo new pages “xxx”之后需要在编辑相应的文件夹下的index.md，按照文档设置type Hexo常用命令###hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 hexo new [layout] 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 hexo generate–&gt;简写hexo g生成静态文件。 hexo publish [layout] 发表草稿。 hexo server启动服务器。默认情况下，访问网址为： http://localhost:4000/。 hexo deploy–&gt; 简写hexo d部署网站。 hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax]]></title>
    <url>%2FAjax-note%2F</url>
    <content type="text"><![CDATA[Ajax简介及原理什么是Ajax Asynchronous JavaScript and XML（异步JavaScript和XML) 的简写 技术核心： XMLHttpRequest 对象 好处：节省用户操作，时间，提高用户体验，减少数据请求 作用：传输获取数据 Ajax过程详解 创建对象XMLHttpRequest() Open方法三个参数的含义 1、提交方式 Form-method 2、提交地址 Form-action 3、异步（同步） Send方法 发送数据请求，相当于Form的submit 请求状态监控 onreadystatechange事件 readyState属性：请求状态 0 （初始化）还没有调用open()方法 1 （载入）已调用send()方法，正在发送请求 2 （载入完成）send()方法完成，已收到全部响应内容 3 （解析）正在解析响应内容 4 （完成）响应内容解析完成，可以在客户端调用了 status属性：服务器(请求资源)的状态 返回的内容 responseText：返回以文本形式存放的内容 responseXML：返回XML形式的内容 发送请求(get和post的区别) send(要发送的数据)：发送请求 中文编码 编码encodeURI 缓存 在url？后面连接一个随机数，时间戳 POST： 数据放在send()里面作为参数传递、post没有缓存问题、无需编码 setRequestHeader(类型, 内容)：设置请求头 “Content-Type”,”application/x-www-form-urlencoded” 数据类型(返回数据的处理) 服务器返回的真正数据 XML、HTML、JSON JSON的写法 Eval解析JSON的时候需要注意 JSON.parse() : 字符串解析成对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //打开浏览器 /* 1.创建一个ajax对象 ie6以下new ActiveXObject('Microsoft.XMLHTTP') */ var xhr = null; /*if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125;*/ try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; //alert( xhr.readyState ); //在地址栏输入地址 /* open方法 参数 1.打开方式 2.地址 3.是否异步 异步:非阻塞 前面的代码不会影响后面代码的执行 同步:阻塞 前面的代码会影响后面代码的执行 */ xhr.open('get','1.txt',true); //提交 发送请求 //alert(1); xhr.send(); //alert( xhr.readyState ); //alert(1) //alert( xhr.responseText ); //等待服务器返回内容 /* readyState : ajax工作状态 responseText : ajax请求返回的内容就被存放到这个属性下面 on readystate change : 当readyState改变的时候触发 status : 服务器状态，http状态码 */ xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; alert( xhr.responseText ); &#125; else &#123; alert('出错了,Err：' + xhr.status); &#125; &#125; &#125; &#125;&#125; GET: 12345678910111213141516171819202122232425262728293031323334window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; var xhr = null; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; /* 1.缓存 在url？后面连接一个随机数，时间戳 2.乱码 编码encodeURI */ xhr.open('get','2.get.php?username='+encodeURI('刘伟')+'&amp;age=30&amp;' + new Date().getTime(),true); xhr.send(); xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; alert( xhr.responseText ); &#125; else &#123; alert('出错了,Err：' + xhr.status); &#125; &#125; &#125; &#125;&#125; POST: 12345678910111213141516171819202122232425262728293031323334window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; var xhr = null; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; xhr.open('post','2.post.php',true); // post方式，数据放在send()里面作为参数传递 xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded');// 申明发送的数据类型 // post没有缓存问题 // 无需编码 xhr.send('username=刘伟&amp;age=30'); xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; alert( xhr.responseText ); &#125; else &#123; alert('出错了,Err：' + xhr.status); &#125; &#125; &#125; &#125;&#125; ajax封装1234567891011121314151617181920212223242526272829303132function ajax(method, url, data, success) &#123; var xhr = null; try &#123; xhr = new XMLHttpRequest(); &#125; catch (e) &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; if (method == 'get' &amp;&amp; data) &#123; url += '?' + data; &#125; xhr.open(method,url,true); if (method == 'get') &#123; xhr.send(); &#125; else &#123; xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function() &#123; if ( xhr.readyState == 4 ) &#123; if ( xhr.status == 200 ) &#123; success &amp;&amp; success(xhr.responseText); &#125; else &#123; alert('出错了,Err：' + xhr.status); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
</search>
